package io.leavesfly.jimi.tool.mcp;

import io.leavesfly.jimi.tool.AbstractTool;
import io.leavesfly.jimi.tool.ToolResult;
import io.modelcontextprotocol.sdk.McpSchema;
import io.modelcontextprotocol.sdk.client.McpClient;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

import java.util.Map;

/**
 * MCP 工具包装器
 * 
 * 将 MCP (Model Context Protocol) 外部工具包装为 Jimi 工具。
 * 支持通过 MCP 协议调用外部工具服务器提供的功能。
 * 
 * 功能特性：
 * 1. 自动发现 MCP 服务器工具
 * 2. 动态参数传递
 * 3. 结果类型转换
 * 4. 超时控制
 * 
 * MCP 工具类型：
 * - STDIO 进程工具（如 npx 启动的服务器）
 * - HTTP 远程工具（如 REST API）
 * - SSE 流式工具
 * 
 * @author 山泽
 */
@Slf4j
public class MCPTool extends AbstractTool<Map<String, Object>> {
    
    private final McpClient mcpClient;
    private final String mcpToolName;
    private final int timeoutSeconds;
    
    /**
     * 创建 MCP 工具包装器
     * 
     * @param mcpTool MCP 工具定义
     * @param mcpClient MCP 客户端
     */
    public MCPTool(McpSchema.Tool mcpTool, McpClient mcpClient) {
        this(mcpTool, mcpClient, 20);  // 默认 20 秒超时
    }
    
    /**
     * 创建 MCP 工具包装器（自定义超时）
     */
    public MCPTool(McpSchema.Tool mcpTool, McpClient mcpClient, int timeoutSeconds) {
        super(
            mcpTool.name(),
            mcpTool.description() != null ? mcpTool.description() : "",
            createParamsClass()
        );
        this.mcpClient = mcpClient;
        this.mcpToolName = mcpTool.name();
        this.timeoutSeconds = timeoutSeconds;
        
        log.debug("Created MCP tool wrapper: {}", mcpToolName);
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public Mono<ToolResult> execute(Map<String, Object> params) {
        return Mono.fromCallable(() -> {
            log.debug("Calling MCP tool: {} with params: {}", mcpToolName, params);
            
            try {
                // 调用 MCP 工具
                McpSchema.CallToolResult mcpResult = mcpClient.callTool(
                    new McpSchema.CallToolRequest(mcpToolName, params)
                );
                
                // 转换结果
                ToolResult result = MCPResultConverter.convert(mcpResult);
                
                log.debug("MCP tool {} returned: {}", mcpToolName, 
                        result.isOk() ? "success" : "error");
                
                return result;
                
            } catch (Exception e) {
                log.error("Failed to call MCP tool: {}", mcpToolName, e);
                return ToolResult.error(
                        "Failed to execute MCP tool: " + e.getMessage(),
                        "MCP tool execution failed"
                );
            }
        });
    }
    
    /**
     * 创建通用参数类（Map 类型）
     */
    @SuppressWarnings("unchecked")
    private static Class<Map<String, Object>> createParamsClass() {
        return (Class<Map<String, Object>>) (Class<?>) Map.class;
    }
}
